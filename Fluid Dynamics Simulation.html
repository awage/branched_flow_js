<!DOCTYPE html>
<!--
	A lattice-Boltzmann fluid simulation in JavaScript, using HTML5 canvas for graphics

	Copyright 2013, Daniel V. Schroeder

	Permission is hereby granted, free of charge, to any person obtaining a copy of
	this software and associated data and documentation (the "Software"), to deal in
	the Software without restriction, including without limitation the rights to
	use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	of the Software, and to permit persons to whom the Software is furnished to do
	so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
	INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
	PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	OTHER DEALINGS IN THE SOFTWARE.

	Except as contained in this notice, the name of the author shall not be used in
	advertising or otherwise to promote the sale, use or other dealings in this
	Software without prior written authorization.

	Credits:
	The "wind tunnel" entry/exit conditions are inspired by Graham Pullan's code
	(http://www.many-core.group.cam.ac.uk/projects/LBdemo.shtml).  Additional inspiration from
	Thomas Pohl's applet (http://thomas-pohl.info/work/lba.html).  Other portions of code are based
	on Wagner (http://www.ndsu.edu/physics/people/faculty/wagner/lattice_boltzmann_codes/) and
	Gonsalves (http://www.physics.buffalo.edu/phy411-506-2004/index.html; code adapted from Succi,
	http://global.oup.com/academic/product/the-lattice-boltzmann-equation-9780199679249).

	Revision history:
	First version, with only start/stop, speed, and viscosity controls, February 2013
	Added resolution control, mouse interaction, plot options, etc., March 2013
	Added sensor, contrast slider, improved tracer placement, Fy period readout, May 2013
	Added option to animate using setTimeout instead of requestAnimationFrame, July 2013
	Added "Flowline" plotting (actually just line segments), August 2013

	Still to do:
	* Fix the apparent bug in the force calculation that gives inconsistent results depending
		on initial conditions.  Perhaps bounce-backs between adjacent barrier sites don't cancel?
	* Grabbing the sensor while "drag fluid" selected causes a momentary drag at previous mouse location.
	* Try to pass two-fingered touch events on to the browser, so it's still possible to zoom in and out.
	* Work on GUI control layout, especially for smaller screens.
	* Treat ends symmetrically when flow speed is zero.
	* Try some other visualization techniques.
-->
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Fluid Dynamics Simulation</title>
<meta charset="utf-8">
<meta name="viewport" content="width=620">
<style>
	body {background-color:#ffffff; font-family:Arial, sans-serif; font-size:14px;
					text-align:center;}						/* gray background, center everything */
	p {margin-left:auto; margin-right:auto; width:600px;}	/* keep paragraphs narrow and centered */
	input {font-size:115%;}									/* make buttons bigger */
	input[type="range"] {width:90px;}						/* make sliders shorter */
	select {font-size:115%;}								/* make selectors bigger too */
	li {text-align:left;}
</style>
</head>

<body>

<h2>Fluid Dynamics Simulation</h2>

<p>By <a href="http://physics.weber.edu/schroeder/">Dan Schroeder</a>,
<a href="http://physics.weber.edu/">Physics Department</a>,
<a href="http://weber.edu/">Weber State University</a></p>

<canvas id="theCanvas" width="600" height="240">This application runs only in modern
browsers. For best results, use Google Chrome.</canvas>

<div>
	<select id="sizeSelect" onchange="resize()">
		<option value="10">60 x 24</option>
		<option value="8">75 x 30</option>
		<option value="6">100 x 40</option>
		<option value="5">120 x 48</option>
		<option value="4">150 x 60</option>
		<option value="3" selected="selected">200 x 80</option>
		<option value="2">300 x 120</option>
		<option value="1">600 x 240</option>
	</select>
	<input id="resetFluidButton" type="button" onclick="initFluid()" value="Reset">
	<input id="stepButton" type="button" onclick="simulate()" value="Step">
	<input id="startButton" type="button" onclick="startStop()" value="Pause">
</div>
<div>
	Animation speed:
	<input id="stepsSlider" type="range" min="1" max="40" step="1" value="20" onchange="resetTimer()">
	&nbsp;&nbsp;Steps per second: <span id="speedReadout">341</span>
	&nbsp;&nbsp;<input id="rafCheck" type="checkbox" checked="checked" onchange="resetTimer()">Faster?
</div>

//<script src="Fluid%20Dynamics%20Simulation_files/barrierdata.js"></script>
<script>
	// Global variables:
	var mobile = navigator.userAgent.match(/iPhone|iPad|iPod|Android|BlackBerry|Opera Mini|IEMobile/i)
	var canvas = document.getElementById('theCanvas');
	var context = canvas.getContext('2d');
	var image = context.createImageData(canvas.width, canvas.height);		// for direct pixel manipulation (faster than fillRect)
	for (var i=3; i<image.data.length; i+=4) image.data[i] = 255;			// set all alpha values to opaque
	var sizeSelect = document.getElementById('sizeSelect');
	sizeSelect.selectedIndex = 5;
	if (mobile) sizeSelect.selectedIndex = 1;		// smaller works better on mobile platforms
	var pxPerSquare = Number(sizeSelect.options[sizeSelect.selectedIndex].value);
													// width of plotted grid site in pixels
	var xdim = canvas.width / pxPerSquare;			// grid dimensions for simulation
	var ydim = canvas.height / pxPerSquare;
	var stepsSlider = document.getElementById('stepsSlider');
	var startButton = document.getElementById('startButton');
	var speedSlider = document.getElementById('speedSlider');
	var speedValue = document.getElementById('speedValue');
	var plotSelect = document.getElementById('plotSelect');
	var contrastSlider = document.getElementById('contrastSlider');
	//var pixelCheck = document.getElementById('pixelCheck');
	var speedReadout = document.getElementById('speedReadout');
	var dataSection = document.getElementById('dataSection');
	var running = false;						// will be true when running
	var stepCount = 0;
	var startTime = 0;
	var sensorX = xdim / 2;						// coordinates of "sensor" to measure local fluid properties
	var sensorY = ydim / 2;
	var draggingSensor = false;
	var mouseIsDown = false;
	var mouseX, mouseY;							// mouse location in canvas coordinates
	var oldMouseX = -1, oldMouseY = -1;			// mouse coordinates from previous simulation frame
	var collectingData = false;
	var time = 0;								// time (in simulation step units) since data collection started
	var showingPeriod = false;
	var lastBarrierFy = 1;						// for determining when F_y oscillation begins
	var lastFyOscTime = 0;						// for calculating F_y oscillation period
	var zoom = 10
	canvas.addEventListener('mousedown', mouseDown, false);
	canvas.addEventListener('mousemove', mouseMove, false);
	document.body.addEventListener('mouseup', mouseUp, false);	// button release could occur outside canvas
	canvas.addEventListener('touchstart', mouseDown, false);
	canvas.addEventListener('touchmove', mouseMove, false);
	document.body.addEventListener('touchend', mouseUp, false);

	// Create the arrays of fluid particle densities, etc. (using 1D arrays for speed):
	// To index into these arrays, use x + y*xdim, traversing rows first and then columns.

	var yy = new Array(2);

	var frame_buffer = new Array(xdim*ydim);

	for (var y=0; y<ydim; y++) {
		for (var x=0; x<xdim; x++) {
			frame_buffer[x+y*xdim] =0;
		}
	}

	yy[0]=0.3; yy[1]=0.5;

	// Set up the array of colors for plotting (mimicks matplotlib "jet" colormap):
	// (Kludge: Index nColors+1 labels the color used for drawing barriers.)
	var nColors = 400;							// there are actually nColors+2 colors
	var hexColorList = new Array(nColors+2);
	var redList = new Array(nColors+2);
	var greenList = new Array(nColors+2);
	var blueList = new Array(nColors+2);
	for (var c=0; c<=nColors; c++) {
		var r, g, b;
		if (c < nColors/8) {
			r = 0; g = 0; b = Math.round(255 * (c + nColors/8) / (nColors/4));
		} else if (c < 3*nColors/8) {
			r = 0; g = Math.round(255 * (c - nColors/8) / (nColors/4)); b = 255;
		} else if (c < 5*nColors/8) {
			r = Math.round(255 * (c - 3*nColors/8) / (nColors/4)); g = 255; b = 255 - r;
		} else if (c < 7*nColors/8) {
			r = 255; g = Math.round(255 * (7*nColors/8 - c) / (nColors/4)); b = 0;
		} else {
			r = Math.round(255 * (9*nColors/8 - c) / (nColors/4)); g = 0; b = 0;
		}
		redList[c] = r; greenList[c] = g; blueList[c] = b;
		hexColorList[c] = rgbToHex(r, g, b);
	}
	redList[nColors+1] = 0; greenList[nColors+1] = 0; blueList[nColors+1] = 0;	// barriers are black
	hexColorList[nColors+1] = rgbToHex(0, 0, 0);

	// Functions to convert rgb to hex color string (from stackoverflow):
	function componentToHex(c) {
		var hex = c.toString(16);
		return hex.length == 1 ? "0" + hex : hex;
	}
	function rgbToHex(r, g, b) {
		return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
	}

	// Initialize array of partially transparant blacks, for drawing flow lines:
	var transBlackArraySize = 50;
	var transBlackArray = new Array(transBlackArraySize);
	for (var i=0; i<transBlackArraySize; i++) {
		transBlackArray[i] = "rgba(0,0,0," + Number(i/transBlackArraySize).toFixed(2) + ")";
	}




	// Mysterious gymnastics that are apparently useful for better cross-browser animation timing:
	window.requestAnimFrame = (function(callback) {
		return 	window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			function(callback) {
				window.setTimeout(callback, 1);		// second parameter is time in ms
			};
	})();

	// Simulate function executes a bunch of steps and then schedules another call to itself:
	function simulate() {
		var stepsPerFrame = Number(stepsSlider.value);			// number of simulation steps per animation frame
		if (mouseIsDown) {
				var gridLoc = canvasToGrid(mouseX, mouseY);
				yy[0] = (gridLoc.x-xdim/2)/zoom;
				yy[1] = (gridLoc.y-ydim/2)/zoom;
			}

		// Execute a bunch of time steps:
		for (var step=0; step<stepsPerFrame; step++) {

			integrate();
			time++;

		}
		paintCanvas();

		if (running) {
			stepCount += stepsPerFrame;
			var elapsedTime = ((new Date()).getTime() - startTime) / 1000;	// time in seconds
			speedReadout.innerHTML = Number(stepCount/elapsedTime).toFixed(0);
		}
		var stable = true;

		if (!stable) {
			window.alert("The simulation has become unstable due to excessive fluid speeds.");
			startStop();
			initFluid();
		}
		if (running) {
			if (rafCheck.checked) {
				requestAnimFrame(function() { simulate(); });	// let browser schedule next frame
			} else {
				window.setTimeout(simulate, 1);	// schedule next frame asap (nominally 1 ms but always more)
			}
		}
	}

	function odefunc(y) {
		var x=y[0]; var v=y[1];
			var k = 1; var m = 0.5; var g = 0;
			return [v, (-k/m)*x + g];
	}

	// Collide particles within each cell (here's the physics!):
	function integrate() {
	 var h=0.001;
	 var k0 = odefunc(yy);
	 var k1 = odefunc([yy[0]+0.5*h*k0[0],yy[1]+0.5*h*k0[1]]);
	 var k2 = odefunc([yy[0]+0.5*h*k1[0],yy[1]+0.5*h*k1[1]]);
	 var k3 = odefunc([yy[0]+    h*k2[0],yy[1]+    h*k2[1]]);

   yy[0] = yy[0]+h/6*(k0[0]+2*(k1[0]+k2[0])+k3[0]);
   yy[1] = yy[1]+h/6*(k0[1]+2*(k1[1]+k2[1])+k3[1]);

	}


	// Paint the canvas:
	function paintCanvas() {
		var cIndex=0;
		var contrast = Math.pow(1.2,Number(contrastSlider.value));
		var plotType = plotSelect.selectedIndex;
		//var pixelGraphics = pixelCheck.checked;

		var x_pos = Math.floor(yy[0]*zoom+xdim/2);
		if(x_pos>xdim) x_pos=xdim;
		if(x_pos<0) x_pos=0;
		var y_pos = Math.floor(yy[1]*zoom+ydim/2);
		if(y_pos>ydim) y_pos=ydim;
		if(y_pos<0) y_pos=0;

		frame_buffer[x_pos+y_pos*xdim] = frame_buffer[x_pos+y_pos*xdim]+0.2;
		if(frame_buffer[x_pos+y_pos*xdim] > 1)
			frame_buffer[x_pos+y_pos*xdim] = 0.99

		/*cIndex = Math.round(nColors * Math.random());
		if (cIndex < 0) cIndex = 0;
		if (cIndex > nColors) cIndex = nColors;
		colorSquare(x_pos, y_pos, redList[cIndex], greenList[cIndex], blueList[cIndex]);*/

		for (var y=0; y<ydim; y++) {
			for (var x=0; x<xdim; x++) {

				//var x = Math.floor(Math.random()*xdim)
				//var y = Math.floor(Math.random()*ydim)

				cIndex = Math.round(nColors * frame_buffer[x+y*xdim]);
				//cIndex = Math.round(nColors * Math.random());


				if (cIndex < 0) cIndex = 0;
				if (cIndex > nColors) cIndex = nColors;

				//if (pixelGraphics) {
					//colorSquare(x, y, cIndex);
				colorSquare(x, y, redList[cIndex], greenList[cIndex], blueList[cIndex]);

			}
		}

		context.putImageData(image, 0, 0);		// blast image to the screen

	}

	// Color a grid square in the image data array, one pixel at a time (rgb each in range 0 to 255):
	function colorSquare(x, y, r, g, b) {

		var flippedy = ydim - y - 1;			// put y=0 at the bottom
		for (var py=flippedy*pxPerSquare; py<(flippedy+1)*pxPerSquare; py++) {
			for (var px=x*pxPerSquare; px<(x+1)*pxPerSquare; px++) {
				var index = (px + py*image.width) * 4;
				image.data[index+0] = r;
				image.data[index+1] = g;
				image.data[index+2] = b;
			}
		}
	}



	// Functions to handle mouse/touch interaction:
	function mouseDown(e) {
		//if (sensorCheck.checked) {
			var canvasLoc = pageToCanvas(e.pageX, e.pageY);
			var gridLoc = canvasToGrid(canvasLoc.x, canvasLoc.y);
			var dx = (gridLoc.x - sensorX) * pxPerSquare;
			var dy = (gridLoc.y - sensorY) * pxPerSquare;
			if (Math.sqrt(dx*dx + dy*dy) <= 8) {
				draggingSensor = true;
			}
		//}
		mousePressDrag(e);
	};
	function mouseMove(e) {
		if (mouseIsDown) {
			mousePressDrag(e);
		}
	};
	function mouseUp(e) {
		mouseIsDown = false;
		draggingSensor = false;
	};

	// Handle mouse press or drag:
	function mousePressDrag(e) {
		e.preventDefault();
		mouseIsDown = true;
		var canvasLoc = pageToCanvas(e.pageX, e.pageY);
		if (draggingSensor) {
			var gridLoc = canvasToGrid(canvasLoc.x, canvasLoc.y);
			sensorX = gridLoc.x;
			sensorY = gridLoc.y;
			paintCanvas();
			return;
		}
		//if (mouseSelect.selectedIndex == 2) {
			mouseX = canvasLoc.x;
			mouseY = canvasLoc.y;
			return;
		//}
		//var gridLoc = canvasToGrid(canvasLoc.x, canvasLoc.y);
		/*if (mouseSelect.selectedIndex == 0) {
			addBarrier(gridLoc.x, gridLoc.y);
			paintCanvas();
		} else {
			removeBarrier(gridLoc.x, gridLoc.y);
		}*/
	}

	// Convert page coordinates to canvas coordinates:
	function pageToCanvas(pageX, pageY) {
		var canvasX = pageX - canvas.offsetLeft;
		var canvasY = pageY - canvas.offsetTop;
		// this simple subtraction may not work when the canvas is nested in other elements
		return { x:canvasX, y:canvasY };
	}

	// Convert canvas coordinates to grid coordinates:
	function canvasToGrid(canvasX, canvasY) {
		var gridX = Math.floor(canvasX / pxPerSquare);
		var gridY = Math.floor((canvas.height - 1 - canvasY) / pxPerSquare); 	// off by 1?
		return { x:gridX, y:gridY };
	}


	// Resize the grid:
	function resize() {
		// First up-sample the macroscopic variables into temporary arrays at max resolution:
		var temp_FB = new Array(canvas.width*canvas.height);

		for (var y=0; y<canvas.height; y++) {
			for (var x=0; x<canvas.width; x++) {
				var tempIndex = x + y*canvas.width;
				var xOld = Math.floor(x / pxPerSquare);
				var yOld = Math.floor(y / pxPerSquare);
				var oldIndex = xOld + yOld*xdim;
				temp_FB[tempIndex] = frame_buffer[oldIndex];
			}
		}
		// Get new size from GUI selector:
		var oldPxPerSquare = pxPerSquare;
		pxPerSquare = Number(sizeSelect.options[sizeSelect.selectedIndex].value);
		var growRatio = oldPxPerSquare / pxPerSquare;
		xdim = canvas.width / pxPerSquare;
		ydim = canvas.height / pxPerSquare;
		// Create new arrays at the desired resolution:
		frame_buffer = new Array(xdim*ydim);

		// Down-sample the temporary arrays into the new arrays:
		for (var yNew=0; yNew<ydim; yNew++) {
			for (var xNew=0; xNew<xdim; xNew++) {
				var rhoTotal = 0;

				for (var y=yNew*pxPerSquare; y<(yNew+1)*pxPerSquare; y++) {
					for (var x=xNew*pxPerSquare; x<(xNew+1)*pxPerSquare; x++) {
						var index = x + y*canvas.width;
						rhoTotal += temp_FB[index];
					}
				}

				frame_buffer[xNew+yNew*xdim] = rhoTotal;
			}
		}

		//computeCurl();
		paintCanvas();
		resetTimer();
	}



	// Function to start or pause the simulation:
	function startStop() {
		running = !running;
		if (running) {
			startButton.value = "Pause";
			resetTimer();
			simulate();
		} else {
			startButton.value = " Run ";
		}
	}

	// Reset the timer that handles performance evaluation:
	function resetTimer() {
		stepCount = 0;
		startTime = (new Date()).getTime();
	}


	// Show or hide the data area:
	function showData() {
		if (dataCheck.checked) {
			dataSection.style.display="block";
		} else {
			dataSection.style.display="none";
		}
	}

	// Start or stop collecting data:
	function startOrStopData() {
		collectingData = !collectingData;
		if (collectingData) {
			time = 0;
			dataArea.innerHTML = "Time \tDensity\tVel_x \tVel_y \tForce_x\tForce_y\n";
			writeData();
			dataButton.value = "Stop data collection";
			showingPeriod = false;
			periodButton.value = "Show F_y period";
		} else {
			dataButton.value = "Start data collection";
		}
	}

	// Write one line of data to the data area:
	function writeData() {
		var timeString = String(time);
		while (timeString.length < 5) timeString = "0" + timeString;
		sIndex = sensorX + sensorY*xdim;
		dataArea.innerHTML += timeString + "\t" + Number(rho[sIndex]).toFixed(4) + "\t"
			+ Number(ux[sIndex]).toFixed(4) + "\t" + Number(uy[sIndex]).toFixed(4) + "\t"
			+ Number(barrierFx).toFixed(4) + "\t" + Number(barrierFy).toFixed(4) + "\n";
		dataArea.scrollTop = dataArea.scrollHeight;
	}

	// Handle click to "show period" button
	function showPeriod() {
		showingPeriod = !showingPeriod;
		if (showingPeriod) {
			time = 0;
			lastBarrierFy = 1.0;	// arbitrary positive value
			lastFyOscTime = -1.0;	// arbitrary negative value
			dataArea.innerHTML = "Period of F_y oscillation\n";
			periodButton.value = "Stop data";
			collectingData = false;
			dataButton.value = "Start data collection";
		} else {
			periodButton.value = "Show F_y period";
		}
	}




	// Print debugging data:
	function debug() {
		dataArea.innerHTML = "Tracer locations:\n";
		for (var t=0; t<nTracers; t++) {
			dataArea.innerHTML += tracerX[t] + ", " + tracerY[t] + "\n";
		}
	}
</script>


</body></html>
